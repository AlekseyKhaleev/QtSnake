/*********************************************************************************************************************
* Данный модуль содержит определения иерархии классов, предназначенных для работы с таблицей данных отдела кадров
* (приложение Lab5-2)
*********************************************************************************************************************/

/* Подключение модулей */

#include <string>
#include <iostream>
#include <vector>
#include <cstring>
#include "Robot.h"

using namespace Fsm_const;
/**********************************************************************************************************************
*                                                class IFsm
***********************************************************************************************************************/

FsmPtr IFsm::CreateInstance() {
    /*******************************************************************************************************************
    * Цель: создание экземпляра производного к IPerson класса
    * Исходные данные:
    *      id - целочисленный идентификатор, содержащий данные о принадлежности к конечному производному классу
    * Результат:
    *   Возврат умного указателя на экземпляр нужного производного класса
    * Вызываемые модули: <memory>
    * Описание алгоритма:
    *  Идентификатор состоит из 5-значного целого числа, первые 2 цифры которого соответствуют конечному классу,
    * являющимся производным от IPerson
    * 1) С помощью операции взятия остатка от деления id на 1000 получаем данные о классе, экземпляр которого необходимо
    * создать.
    * 2) С помощью умного указателя создаем экземпляр нужного класса.
    * 3) Возвращаем указатель на созданный экземпляр класса.
    * В случае если запрошенного класса не существует вызываем соответствующее исключение класса SyntaxException
    * Дата: 07 / 06 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *******************************************************************************************************************/

    return std::make_shared<Robot>();  // возврат умного указателя на экземпляр класса Robot

}

Robot::Robot() = default;

Robot::~Robot() = default;

void Robot::SetState(bool (*state)()){
    ActiveState = state;
}

void Robot::Update(){
    if (ActiveState != nullptr) {
        ActiveState();
    }
}

const char *Robot::GetArrow(){
    return arrow;
}

bool Robot::wait(signal sig){

    std::cout<<u8' ';
    //move_cursor(CS);
    //std::cout<<GetArrow();
    //move_coursor(title);
    //std::cout<<"Current position (x,y): << CS;
    return 1;
}

bool Robot::analyze()
{
    return 0;
}

bool Robot::turn()
{
    return 0;
}

bool Robot::move()
{
    return 0;
}

bool Robot::exit()
{
    return 0;
}

bool Robot::left()
{
    return 0;
}

bool Robot::right()
{
    return 0;
}

QPoint Robot::SigHandle(signal sig){
    if (sig[1]) {
        SetState(analyze);
        Update();
    }
    return CS;
}


